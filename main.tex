% !TeX encoding = UTF-8 Unicode
\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage[english]{isodate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{centernot}
\usepackage{xfrac}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{changepage}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{soul}
\usepackage{float}
\usepackage{centernot}
\usepackage{tcolorbox}
\usepackage{titling}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{etoolbox}
\usepackage{listings}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{titlesec}
\usepackage{tikz}

\addbibresource{bibliography.bib}

\patchcmd{\section}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsection}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsubsection}{\bfseries}{\bfseries\boldmath }{}{}

\hypersetup{
  colorlinks=True,
  urlcolor=blue,
  citecolor=red,
  menucolor=black,
}

\renewcommand{\UrlFont}{\ttfamily\footnotesize}

\lstdefinelanguage{futhark}
{
  % list of keywords
  morekeywords={
    do,
    else,
    for,
    if,
    in,
    include,
    let,
    loop,
    then,
    type,
    val,
    while,
    with,
    module,
    def,
    entry,
    local,
    open,
    import,
    assert,
    match,
    case,
  },
  sensitive=true, % Keywords are case sensitive.
  morecomment=[l]{--}, % l is for line comment.
  morestring=[b]" % Strings are enclosed in double quotes.
}


\lstset{
    language=futhark,
    showspaces=false,
    showstringspaces=false,
    mathescape=true,
    aboveskip=0pt,
    belowskip=6pt,
    numberstyle=\tiny,
    numbers=left, 
    firstnumber=1,
    numberfirstline=true,
    tabsize=4,
    breaklines=true,
}

\newcommand\LAST{\text{LAST}}
\newcommand\defiff{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{\iff}}}
\newcommand\defeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}
\newcommand\concat{\: \mathrlap{+} \: +}
\newcommand\map{\textbf{map}\ }
\newcommand\reduce{\textbf{reduce}\ }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem*{remark}{Remark}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}
\newtheorem{algorithm}{Algorithm}[section]
\newtheorem{example}{Example}[section]
\DeclareMathOperator{\sign}{sign}
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\id}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Let}{\kw{let}}
\newcommand{\In}{\kw{in}}
\newcommand{\If}{\kw{if}}
\newcommand{\Then}{\kw{then}}
\newcommand{\Else}{\kw{else}}
\newcommand{\Filter}{\kw{filter}}
\newcommand{\Or}{\kw{or}}
\newcommand{\Groupby}{\kw{groupby}}
\newcommand{\Partition}{\kw{partition}}
\newcommand{\Scatter}{\kw{scatter}}
\newcommand{\Hist}{\kw{hist}}
\newcommand{\Map}{\kw{map}}
\newcommand{\Sum}{\kw{sum}}
\newcommand{\Mod}{\kw{mod}}
\newcommand{\Fst}{\kw{fst}}
\newcommand{\Snd}{\kw{snd}}
\newcommand{\Presum}{\kw{presum}}
\newcommand{\True}{\kw{true}}
\newcommand{\False}{\kw{false}}
\newcommand{\Sort}{\kw{sort}}
\newcommand{\Segor}{\kw{segor}}
\newcommand{\Hash}{\kw{hash}}
\newcommand{\Random}{\kw{random}}
\newcommand{\Iota}{\kw{iota}}
\newcommand{\Unzip}{\kw{unzip}}
\newcommand{\Unit}{\mathbf{unit}}
\newcommand{\Int}{\mathbf{int}}
\newcommand{\Bool}{\mathbf{bool}}
\newcommand{\Def}{\kw{def}}
\newcommand{\Rep}{\kw{rep}}
\newcommand{\Zip}{\kw{zip}}

\fancyhf{}
\setlength{\headheight}{14.49998pt}
\pretitle{\vspace{-120pt}\begin{center}}
\posttitle{\par\end{center}\vspace{-80pt}}
\fancyhead[C]{}
\fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
\pagestyle{fancy}
\fancypagestyle{firstpage}{%
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
}
\title{
    {\Large \textsc{University of Copenhagen}} \\[5pt]
    {\large Union-Find} \\[10pt]
    Author: William Henrich Due \\[0pt]
}
\author{}
\date{}

\begin{document}
\maketitle
\thispagestyle{firstpage}

\section{Definitions}

\begin{definition}[Union-Find]\label{def:union-find} The
    union-find data structure $U$ represents a partition of a set $S$ if:
    \begin{enumerate}
        \item $a \neq \emptyset$ for all $a \in \mathcal{C}(U)$
        \item $a \cap b = \emptyset$ for all $a, b \in \mathcal{C}(U)$ where $a
        \neq b$
        \item $\bigcup_{a \in \mathcal{C}(U)} a = S$
    \end{enumerate}
    where $\mathcal{C} : \mathbb{P}(U) \to \mathbb{P}(\mathbb{P}(S))$ converts
    the data structure $U$ into a partition of $S$.
\end{definition}

\begin{definition}[Cycle]
    A cycle in a directed graph $G = (V, E)$ is a sequence of directed edges
    $e_1, e_2, \ldots, e_m \in E$ where $e_i = (v_{i-1}, v_i)$ for $1 \leq i
    \leq m$ such that $v_0 = v_m$ and $m > 0$.
\end{definition}

\begin{definition}[Forest]
    A forest is a directed graph $F = (V, E)$ where $V$ is a set of vertices and $E
    \subseteq V \times V$ is a set of directed edges such that:
    \begin{enumerate}
        \item There are no cycles.
        \item Each node has at most one parent i.e. for all $(u, v_1), (u, v_2) \in E$ it
        holds that $v_1 = v_2$.
    \end{enumerate}
\end{definition}

\begin{definition}[Reachability]
    A node $v$ is \emph{reachable} from a node $u$ in a directed graph $G = (V,
    E)$ if there exists a sequence of directed edges $e_1, e_2, \ldots, e_m \in
    E$ (possibly $m = 0$) where $e_i = (v_{i-1}, v_i)$ for $1 \leq i \leq m$,
    such that $v_0 = u$ and $v_m = v$. We denote this by $u \leadsto v$.
\end{definition}

\begin{definition}[Union-Find Structure]
    The union-find data structure $U$ is a forest $U = (V, E)$ where the
    vertices $V = S$. The edges $E \subseteq V \times V$ represent parent
    relations between elements in $S$ such that $(u, v) \in E$ means that $u$ has
    parent $v$. An element $u$ with no parent is represented by $(u, 0) \in E$ where
    $0 \notin S$.
\end{definition}

\begin{definition}[Root]
    A node $v \in V$ in a union-find data structure $U = (V, E)$ is a root if it
    has no parent i.e. $\mathcal{R}_U(v) : |\{u : u \in V \land v \leadsto u\}| = 1$.
\end{definition}

\begin{definition}[Find Root]
    The root $r \in V$ of node $v \in V$ in a union-find data structure $U = (V,
    E)$ is defined as:
    \begin{enumerate}
        \item $r$ is a root node and
        \item there is path from $v$ to $r$ i.e. $v \leadsto r$.
    \end{enumerate}
\end{definition}

\begin{proposition}[Unique Root]
    In a union-find data structure $U = (V, E)$ each node $v \in V$ has exactly
    one root.
\end{proposition}
\begin{proof}
    
\end{proof}

\begin{proposition}[Representation of
    Union-Find]\label{def:representation-union-find} A cycleless union-find structure $U
    \in \mathbb{U}_n$ fulfills definition \ref{def:union-find} for the following conversion function:
    \begin{align*}
        \mathcal{C}(U) := \{\{f(\pi_1(u)) : u \in U \land \mathcal{P}_U(\pi_1(u)) = p \} : p \in \mathbb{N}_{\leq n}\} \backslash \{\emptyset\}
    \end{align*}
    where $f : \mathbb{N}_{\leq n} \to S$ is a bijective function mapping
    indices to elements in the set $S$.
\end{proposition}
\begin{proof}
    Let $U \in \mathbb{U}_n$ be a union-find data structure fulfilling the three
    criteria in proposition \ref{def:representation-union-find}. We will show
    that $U$ fulfills the three criteria in definition \ref{def:union-find}.

    \begin{enumerate}
        \item By definition of $\mathcal{C}$ it is clear that $a \neq \emptyset$
        for all $a \in \mathcal{C}(D)$ since $\mathcal{C}$ only includes
        non-empty sets.
        \item Let $a, b \in \mathcal{C}(D)$ where $a \neq b$ then by definition
        $a = \{f(\pi_1(u)) : u \in U \land \mathcal{P}_U(\pi_1(u)) = p_a \}$ and
        $b = \{f(\pi_1(u)) : u \in U \land \mathcal{P}_U(\pi_1(u)) = p_b \}$ for
        some $p_a, p_b \in \mathbb{N}_{\leq n}$ where $p_a \neq p_b$. Since if
        $p_a = p_b$ then $a = b$ it follows that $a \cap b = \emptyset$.
        \item Let $s \in S$ then since $U$ is a union-find data structure of size
        $n$ there exists $(i, p) \in U$ for some $i$ and $p$. Let $r =
        \mathcal{P}_U(i)$ then by definition of $\mathcal{C}$ it follows that $s
        \in \{f(\pi_1(u)) : u \in U \land \mathcal{P}_U(\pi_1(u)) = r \} \in
        \mathcal{C}(U)$. Since $s$ was arbitrary it follows that $\bigcup_{a \in
        \mathcal{C}(U)} a = S$.
    \end{enumerate}
\end{proof}

\begin{definition}[Substitute Parent]
    The function for substitution a parent of an element $i$ to $p$ in a
    cycleless union-find data structure $U \in \mathbb{U}_n$ is denoted
    $\mathcal{S}_U : \mathbb{N}_{\leq n} \times \mathbb{N}_{\leq n} \to
    \mathbb{P}(\mathbb{U}_n)$ and defined as:
    \begin{align*}
        \mathcal{S}_U(i, p) := (U \backslash \{(i, p')\}) \cup \{(i, p)\} \text{ where } (i, p') \in U
    \end{align*}
\end{definition}

\begin{definition}[Equivalence Set]
    The set of equivalent indices of an element $i$ in a cycleless union-find
    data structure $U \in \mathbb{U}_n$ is defined as:
    \begin{align*}
        \mathcal{E}_U(i) := \{j : j \in \mathbb{N}_{\leq n} \land \mathcal{P}_U(j) = \mathcal{P}_U(i)\}
    \end{align*}
\end{definition}

\begin{definition}[Parent]
    A element $i \in \mathbb{N}_{\leq n}$ has a parent $p \in \mathbb{N}_{\leq n} 
    \cup \{0\}$ if 
\end{definition}

\begin{definition}[Equivalent Union-Find Structures]
    Two cycleless union-find data structures $U, U' \in \mathbb{U}_n$ are
    equivalent if:
    \begin{align*}
        \mathcal{E}_{U'}(i) = \mathcal{E}_U(i) \text{ for all } i \in \mathbb{N}_{\leq n}
    \end{align*}
\end{definition}
\begin{lemma}[Cycleless substitution]
    A parent substitution $\mathcal{S}_U(i, p)$ of a cycleless union-find
    data structure $U \in \mathbb{U}_n$ will result in a cycleless union-find
    data structure if:
    \begin{align*}
        \mathcal{P}_U(i) \neq \mathcal{P}_U(p)
    \end{align*} 
\end{lemma}
\begin{proof}
    
\end{proof}

\begin{definition}[Well-formed Union]
    For a cycleless union-find data structure $U \in \mathbb{U}_n$ the union of
    two elements $i \sim j$ where $i, j \in \mathbb{N}_{\leq n}$ is well-formed
    if it results in a cycleless union-find data structure $U' \in \mathbb{U}_n$
    such that:
    \begin{enumerate}
        \item $\mathcal{E}_{U'}(i) = \mathcal{E}_U(i) \cup \mathcal{E}_U(j)$ and
        \item $\mathcal{E}_{U'}(k) = \mathcal{E}_U(k) \text{ for all } k \in
        \mathbb{N}_{\leq n} \backslash (\mathcal{E}_U(i) \cup \mathcal{E}_U(j))$.
    \end{enumerate}
\end{definition}

\begin{definition}[Sequential Unions]\label{def:sequential-unions}
    Given a sequence of union relations $i_1 \sim j_1, i_2 \sim j_2, \ldots, i_m
    \sim j_m$ where $i_k, j_k \in \mathbb{N}_{\leq n}$ for all $1 \leq k \leq m$
    and a initial  $U \in \mathbb{U}_n$. The final union-find data structure $U'
    \in \mathbb{U}_n$ is
    defined as:
    \begin{align*}
        U_0 &:= \{(i, 0) : i \in \mathbb{N}_{\leq n}\} \\
        (q_k, p_k) &:= (\mathcal{P}_{U_{k-1}}(i_k), \mathcal{P}_{U_{k-1}}(j_k)) \text{ for } 1 \leq k \leq m \\
        U_k &:= \begin{cases}
            U_{k-1} & \text{if } p_k = q_k \\
            \mathcal{S}_{U_{k-1}}(q_k, p_k) & \text{if } p_k \neq q_k
        \end{cases} \text{ for } 1 \leq k \leq m \\
        U' &:= U_m
    \end{align*}
\end{definition}

\begin{proposition}[Sequential Unions is Well-formed]
    Given a sequence of union relationss $i_1 \sim j_1, i_2 \sim j_2, \ldots,
    i_m \sim j_m$ where $i_k, j_k \in \mathbb{N}_{\leq n}$ for all $1 \leq k
    \leq m$ and a cycleless union-find data structure $U \in \mathbb{U}_n$. The
    final union-find data structure $U' \in \mathbb{U}_n$ defined in definition
    \ref{def:sequential-unions} is well-formed.
\end{proposition}
\begin{proof}
    To prove that $U'$ is well-formed we need to show that each union in the
    sequence is well-formed. This can be shown by induction on the index $k$ of
    the union in the sequence.
    \begin{itemize}
        \item For $U_0$ it is clear that $\mathcal{E}_{U_0}(i) = \{i\}$ for all $i \in
        \mathbb{N}_{\leq n}$ since all elements are their own root.
        \item Assume that $U_{k-1}$ is well-formed for some $1 \leq k \leq m$.
        We will show that $U_k$ is well-formed. Let $q_k
        =\mathcal{P}_{U_{k-1}}(i_k)$ and $p_k = \mathcal{P}_{U_{k-1}}(i_k)$.
        \begin{enumerate}
            \item If $p_k = q_k$ then by definition $U_k = U_{k-1}$ and thus
            $U_k$ is well-formed by the inductive hypothesis.
            \item If $p_k \neq q_k$ then since $q_k$ is a root $(q_k, 0) \in U_{k - 1}$ and by definition
            of $\mathcal{S}$.
            \begin{align*}
                U_k := (U_{k-1} \backslash \{(q_k, 0)\}) \cup \{(q_k, p_k)\} \text{ where } (q_k, 0) \in U_{k-1}
            \end{align*}
            Now $p_k = \mathcal{P}_{U_k}(q_k)$ hence $\mathcal{P}_{U_k}(q) = p_k$ for all $q
            \in \mathcal{E}_{U_{k - 1}}(q_k)$. And by definition of $p_k$ being
            a root it follows that $\mathcal{P}_{U_k}(p) = p_k$ for all $p \in
            \mathcal{E}_{U_{k - 1}}(p_k)$. Thus $\mathcal{E}_{U_k}(i_k) =
            \mathcal{E}_{U_{k - 1}}(i_k) \cup \mathcal{E}_{U_{k - 1}}(j_k)$ and
            since all other elements are unaffected by the union it follows that
            $\mathcal{E}_{U_k}(l) = \mathcal{E}_{U_{k - 1}}(l)$ for all $l \in
            \mathbb{N}_{\leq n} \backslash (\mathcal{E}_U(i) \cup
            \mathcal{E}_U(j))$.

            Finally since $U_{k-1}$ is cycleless and $q_k$ is a root it follows
            that $U_k$ is cycleless and thus $U_k$ is well-formed.
        \end{enumerate}
    \end{itemize}
\end{proof}

\begin{definition}[Parallel Unions]
\end{definition}
\end{document}
