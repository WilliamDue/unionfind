% !TeX encoding = UTF-8 Unicode
\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage[english]{isodate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{centernot}
\usepackage{xfrac}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{changepage}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{soul}
\usepackage{float}
\usepackage{centernot}
\usepackage{tcolorbox}
\usepackage{titling}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{etoolbox}
\usepackage{listings}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{titlesec}
\usepackage{tikz}

\addbibresource{bibliography.bib}

\patchcmd{\section}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsection}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsubsection}{\bfseries}{\bfseries\boldmath }{}{}

\hypersetup{
  colorlinks=True,
  urlcolor=blue,
  citecolor=red,
  menucolor=black,
}

\renewcommand{\UrlFont}{\ttfamily\footnotesize}

\lstdefinelanguage{futhark}
{
  % list of keywords
  morekeywords={
  do,
  else,
  for,
  if,
  in,
  include,
  let,
  loop,
  then,
  type,
  val,
  while,
  with,
  module,
  def,
  entry,
  local,
  open,
  import,
  assert,
  match,
  case,
  },
  sensitive=true, % Keywords are case sensitive.
  morecomment=[l]{--}, % l is for line comment.
  morestring=[b]" % Strings are enclosed in double quotes.
}


\lstset{
  language=futhark,
  showspaces=false,
  showstringspaces=false,
  mathescape=true,
  aboveskip=0pt,
  belowskip=6pt,
  numberstyle=\tiny,
  numbers=left, 
  firstnumber=1,
  numberfirstline=true,
  tabsize=4,
  breaklines=true,
}

\newcommand\LAST{\text{LAST}}
\newcommand\defiff{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{\iff}}}
\newcommand\defeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}
\newcommand\concat{\: \mathrlap{+} \: +}
\newcommand\map{\textbf{map}\ }
\newcommand\reduce{\textbf{reduce}\ }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem*{remark}{Remark}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}
\newtheorem{algorithm}{Algorithm}[section]
\newtheorem{example}{Example}[section]
\DeclareMathOperator{\sign}{sign}
\newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\newcommand{\id}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\kw}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\Let}{\kw{let}}
\newcommand{\In}{\kw{in}}
\newcommand{\If}{\kw{if}}
\newcommand{\Then}{\kw{then}}
\newcommand{\Else}{\kw{else}}
\newcommand{\Filter}{\kw{filter}}
\newcommand{\Or}{\kw{or}}
\newcommand{\Groupby}{\kw{groupby}}
\newcommand{\Partition}{\kw{partition}}
\newcommand{\Scatter}{\kw{scatter}}
\newcommand{\Hist}{\kw{hist}}
\newcommand{\Map}{\kw{map}}
\newcommand{\Sum}{\kw{sum}}
\newcommand{\Mod}{\kw{mod}}
\newcommand{\Fst}{\kw{fst}}
\newcommand{\Snd}{\kw{snd}}
\newcommand{\Presum}{\kw{presum}}
\newcommand{\True}{\kw{true}}
\newcommand{\False}{\kw{false}}
\newcommand{\Sort}{\kw{sort}}
\newcommand{\Segor}{\kw{segor}}
\newcommand{\Hash}{\kw{hash}}
\newcommand{\Random}{\kw{random}}
\newcommand{\Iota}{\kw{iota}}
\newcommand{\Unzip}{\kw{unzip}}
\newcommand{\Unit}{\mathbf{unit}}
\newcommand{\Int}{\mathbf{int}}
\newcommand{\Bool}{\mathbf{bool}}
\newcommand{\Def}{\kw{def}}
\newcommand{\Rep}{\kw{rep}}
\newcommand{\Zip}{\kw{zip}}

\fancyhf{}
\setlength{\headheight}{14.49998pt}
\pretitle{\vspace{-120pt}\begin{center}}
\posttitle{\par\end{center}\vspace{-80pt}}
\fancyhead[C]{}
\fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
\pagestyle{fancy}
\fancypagestyle{firstpage}{%
  \fancyhf{}
  \renewcommand{\headrulewidth}{0pt}
  \fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
}
\title{
  {\Large \textsc{University of Copenhagen}} \\[5pt]
  {\large Union-Find} \\[10pt]
  Author: William Henrich Due \\[0pt]
}
\author{}
\date{}

\begin{document}
\maketitle
\thispagestyle{firstpage}

\section{Theory}

\subsection{Forests}
\begin{definition}[Reachability]
  A node $v$ is \emph{reachable} from a node $u$ in a directed graph $G = (V,
  E)$ if there exists a sequence of directed edges $e_1, e_2, \ldots, e_m \in
  E$ where $m \geq 1$ and $e_i = (v_{i-1}, v_i)$ for $1 \leq i \leq m$,
  such that $v_0 = u$ and $v_m = v$. We denote this by $u \leadsto v$.
\end{definition}

\begin{definition}[Cycle]
  A cycle in a directed graph $G = (V, E)$ has a cycle if there exists
  $v \in V$ such that $v \leadsto v$.
\end{definition}

\begin{definition}[Forest]
  A forest is a directed graph $F = (V, E)$ where $V$ is a set of vertices and $E
  \subseteq V \times V$ is a set of directed edges such that:
  \begin{enumerate}
    \item There are no cycles $v \centernot\leadsto v$ for all $v \in V$, and
    \item each node has at most one parent i.e. for all $(u, v_1), (u, v_2)
    \in E$ it holds that $v_1 = v_2$.
  \end{enumerate}
\end{definition}

\begin{definition}[Root]
  A node $v \in V$ in a forest $F = (V, E)$ is a root if it has no parent.
  This is defined as the predicate:
  \begin{align*}
    \mathcal{R}_F(v) : v \centernot\leadsto u \text{ for all } u \in V
  \end{align*}
\end{definition}

\begin{definition}[Tree]
  A tree is a forest $T = (V, E)$ where there exists a unique root $r \in V$
  such that $v \leadsto r$ for all $v \in V\backslash
  \{r\}$.
\end{definition}

\begin{proposition}[Forest Root Count]\label{prop:forest-root-count}
  A forest $F = (V, E)$ where $|V| = n$ and $|E| = n - k$ has $k$ roots.
\end{proposition}

\begin{proof}
  Let $F = (V, E)$ be a forest where $|V| = n$ and $|E| = n - k$. By the
  second property of a forest then $n - k$ vertices must have a parent. Since
  there are $n$ vertices in total it follows that there are exactly $k$
  vertices $r_1, r_2, \ldots, r_k \in V$ that has no parent. Hence there are
  exactly $k$ roots in $F$.
\end{proof}

\begin{proposition}[Roots Path Exist]\label{prop:roots-path-exist}
  In a forest $F = (V, E)$ for each element $v \in V$ there exists at least
  one root $r \in V$ such that $\mathcal{R}_F(r)$ and either $v \leadsto r$ or
  $v = r$.
\end{proposition}

\begin{proof}
  Let $F = (V, E)$ be a forest and let $v \in V$ be an arbitrary element in
  $V$. By proposition \ref{prop:forest-root-count} there exists at least one
  root $r \in V$ such that $\mathcal{R}_F(r)$. This can be shown by structural
  induction on a vertex $v \in V$ that any $(v, p) \in E$ then either $p = r$
  or $p$ has a path to some root $r \in V$.
  \begin{itemize}
    \item If $p = r$ then $p$ is a root and $v$ has a path to a root $r$ by
    $(v, r) \in E$.
    \item By induction hypothesis $p$ has a path to a root $r \in V$ such
    that $\mathcal{R}_F(r)$. Since $(v, p) \in E$ it follows that $v
    \leadsto p \leadsto r$ so .
  \end{itemize}
\end{proof}

\begin{proposition}[Forest Edge Limit]\label{prop:forest-edge-limit}
  A forest $F = (V, E)$ where $|V| = n$ and $|E| > n - 1$ is not a forest.
\end{proposition}

\begin{proof}
  Let $F = (V, E)$ be a forest where $|V| = n$ and $|E| > n - 1$. By
  proposition \ref{prop:forest-root-count} a forest with $n - 1$ has exactly
  one root, so it is a tree. By adding one more edge to the tree it must make
  one vertex have two parents. Or since every vertex $v \in V$ has a path to
  the root $r \in V$ it must create a cycle $v \leadsto v$ for some $v \in V$.
  In both cases it contradicts the properties of a forest.
\end{proof}

\subsection{Union-Find Structure}

\begin{definition}[Union-Find Structure]
  The union-find structure $U$ is a forest $U = (V, E)$ where the vertices $V
  = S$ for some set of elements $S$. The edges $E \subseteq V \times V$
  represent parent relations between elements in $S$ such that $(u, v) \in E$
  means that $u$ has parent $v$.
\end{definition}

\begin{definition}[Representative]
  The representative of an element $v \in V$ in a forest $F = (V, E)$ is the
  root $r \in V$ such that there is a path from $v$ to $r$. This is defined as
  the function:
  \begin{align*}
    \rho_F(v) := r \text{ where } r \in V \text{ such that } \mathcal{R}_F(r) \land (v \leadsto r \lor v = r)
  \end{align*}
\end{definition}

\begin{proposition}[Unique Representative]
  In a forest $F = (V, E)$ each element $v \in V$ has a unique
  representative $\rho_F(v)$.
\end{proposition}

\begin{proof}
  Let $F = (V, E)$ be a union-find structure and let $v \in V$ be an arbitrary
  element in $V$. By proposition \ref{prop:roots-path-exist} there exists at
  least one root $r \in V$ such that $\mathcal{R}_F(r)$ and $v \leadsto r$.
  Now assume that there exists another root $r' \in V$ such that $\mathcal{R}_F(r')$
  and $v \leadsto r'$. Since $F$ is a forest it follows by the second property
  of a forest that $r = r'$ hence the representative is unique.
\end{proof}

\begin{definition}[Tree Set]
  The set of vertices of the same tree $\mathcal{E}_F(v)$ in a
  forest $F = (V, E)$ is defined as:
  \begin{align*}
    \mathcal{E}_F(v) := \{u : u \in V \text{ where } \rho_F(u) = \rho_F(v))\}
  \end{align*}
\end{definition}

\begin{definition}[Partition]\label{def:partition}
  The set $P \subseteq \mathbb{P}(S)$ is a partition of a set $S$ if:
  \begin{enumerate}
    \item $a \neq \emptyset$ for all $a \in P$
    \item $a \cap b = \emptyset$ for all $a, b \in P$ where $a
    \neq b$
    \item $\bigcup_{a \in P} a = S$
  \end{enumerate}
\end{definition}

\begin{proposition}[Forest Partition]\label{prop:forest-partition}
  A forest $F = (V, E)$ is a partition of $V$ for the following set:
  \begin{align*}
    \{\mathcal{E}_F(v) : v \in V\}
  \end{align*}
\end{proposition}

\begin{proof}
  Let $F = (V, E)$ be a forest. We will show that the set in the proposition
  is a partition of $V$ by showing that it satisfies the three properties in
  definition \ref{def:partition}.
  \begin{enumerate}
    \item By definition of $\mathcal{E}_F(v)$ it can not be empty since for
    $\mathcal{E}_F(v)$ then $\rho_F(v) = \rho_F(v)$. Hence $\mathcal{E}_F(v)
    \neq \emptyset$ for all $v \in V$.
    \item Let $a$ and $b$ be two arbitrary elements in the set such that $a
    \neq b$. By definition of $a$ and $b$ there exists $v_1, v_2 \in V$ such
    that $a = \{u : u \in V \land \rho_F(u) = \rho_F(v_1)\}$ and $b = \{u :
    u \in V \land \rho_F(u) = \rho_F(v_2)\}$. Since $a \neq b$ it follows
    that $\rho_F(v_1) \neq \rho_F(v_2)$ since otherwise $a = b$, hence $a
    \cap b = \emptyset$.
    \item Let $v$ be an arbitrary element in $V$. By proposition
    \ref{prop:roots-path-exist} there exists a root $r \in V$ such that
    $\mathcal{R}_F(r)$ and $v \leadsto r$ or $v = r$. By definition of the
    representative it follows that $\rho_F(v) = r$. Now let $a = \{u : u \in
    V \land \rho_F(u) = \rho_F(v)\}$. By definition of $a$ it follows that
    $v \in a$. Since $v$ was arbitrary it follows that $\bigcup_{a \in P} a
    = V$.
  \end{enumerate}
\end{proof}

\begin{definition}[Same Tree Relation]
  The relation $\sim_F$ on a forest $F$ is defined as:
  \begin{align*}
    u \sim_F v :\iff u \in \mathcal{E}_F(v)
  \end{align*}
\end{definition}

\begin{corollary}[Same Tree Relation is an Equivalence Relation]
  The relation $\sim_F$ on a forest $F$ is an equivalence relation due to
  $\{\mathcal{E}_F(v) : v \in V\}$ being a partition of $V$. by proposition
  \ref{prop:forest-partition}.
\end{corollary}

\begin{definition}[Forests with Equivalent Tree Sets]
  Two forests $F = (V, E)$ and $F' = (V', E')$ have equivalent tree sets $F
  \cong F'$ if:
  \begin{itemize}
    \item Vertices are the same $V = V'$.
    \item The tree sets are equivalent $\mathcal{E}_{F}(v) =
    \mathcal{E'}_F(v)$ for all $v \in V$.
  \end{itemize}
\end{definition}

\begin{definition}[Tree Union]
  The tree union of two elements $v$ and $u$ for a forest $F = (V, E)$ is such
  that $v \sim_{F'} u$ in a new forest $F' = (V', E')$ and $F'$ satify the
  following properties:
  \begin{enumerate}
    \item $\mathcal{E}_{F'}(v) = \mathcal{E}_{F'}(u) = \mathcal{E}_F(v) \cup \mathcal{E}_F(u)$ and
    \item $\mathcal{E}_{F'}(w) = \mathcal{E}_F(w) \text{ for all } w \in V
    \backslash (\mathcal{E}_F(v) \cup \mathcal{E}_F(u))$.
  \end{enumerate}
\end{definition}

\begin{proposition}[Tree Union]\label{def:tree-union}
  Let forest $F = (V, E)$, $p = \rho_F(u)$ be the representative of $u$ and
  let $q = \rho_F(v)$ be the representative of $v$ where $q \neq p$. Then
  defined $F'$ as:
  \begin{align*}
    F' &:= (V, E \cup \{(q, p)\})
  \end{align*}
  Then $u \sim_{F'} v$ in $F'$ and $F'$ will satisfy the properties of a tree
  union.
\end{proposition}

\begin{proof}
  Let $F = (V, E)$, $p = \rho_F(u)$ be the representative of $u$ and let $q =
  \rho_F(v)$ be the representative of $v$. By definition $q$ will have parent
  $p$ in $F'$ and since $q$ is a root it has no parent then $F'$ is a forest.
  Now for all $w \in \mathcal{E}_F(q)$ it holds that $w \leadsto q$ or $q = w$
  and since $q \leadsto p$ it follows that $w \leadsto p$. Hence $w \in
  \mathcal{E}_{F'}(p)$ for all $w \in \mathcal{E}_F(q)$ and trivially $w \in
  \mathcal{E}_{F'}(p)$ for all $w \in \mathcal{E}_F(p)$ so it follows that
  $\mathcal{E}_{F'}(v) = \mathcal{E}_{F'}(u) = \mathcal{E}_F(v) \cup
  \mathcal{E}_F(u)$. Now let $w \in V \backslash (\mathcal{E}_F(v) \cup
  \mathcal{E}_F(u))$ be an arbitrary element. Since $w \centernot\leadsto p$,
  $w \neq p$, $w \centernot\leadsto q$, and $w \neq q$ it follows that $w$ has
  the same representative in $F'$ as in $F$ hence $\mathcal{E}_{F'}(w) =
  \mathcal{E}_F(w)$.
\end{proof}

\subsection{Parallel Union-Find}

\begin{definition}[Conflict-free Set]
  Let $F$ be a forest, $X \subseteq \{(\rho_F(v), \rho_F(u)) : (v, u) \in V
  \times V\}$ be a set of root pairs. Then $X$ is a conflict-free set in $F$
  if $(V, Y)$ is a forest.
\end{definition}

\begin{proposition}[Conflict-free Forest Union]\label{prop:conflict-free-forest-union}
  Let forest $F = (V, E)$ be a forest and let $X \subseteq V \times V$ be a
  conflict-free set in $F$ where $|X| = n$. Then defining the following forests:
  \begin{align*}
    F_0 &:= F \\
    F_{i} &:= (V, E_{i - 1} \cup \{(v_i, u_i)\}) \text{ for } (v_i, u_i) \in X \text{ and } 1 \leq i \leq n
  \end{align*}
  Then $F_n$ is a forest.
\end{proposition}

\begin{proof}
  Let forest $F = (V, E)$ be a forest, $X \subseteq V \times V$ be a
  conflict-free set in $F$. We will show that $F_n$ is a forest by induction
  on $i$.
  \begin{itemize}
    \item Base case: If $i = 0$ then $F_i = F_0 = F$ which is a forest.
    \item Induction hypothesis: Assume that $F_{i - 1}$ is a forest for all
    $1 \leq i < n$.  Let $(v_i, u_i) \in X$, we know that $v_i \neq v_j$ for
    all $(v_j, u_j) \in Y \backslash \{(v_i, u_i)\}$ since otherwise $(V,
    X)$ would not be a forest and $X$ would not be a conflict-free set in
    $F$. So $v_i$ will only have one parent in $F_i$ since it only appears
    once as a child in $(V, X)$. By definition all of the edges in $X$
    consists of roots in $F$, and since $(V, X)$ is a forest there are no
    cycles $y \centernot\leadsto y$ for all $y \in V$ in $F_i$. Hence $F_i$
    is a forest.
  \end{itemize}
  Thus by induction $F_n$ is a forest.
\end{proof}

\begin{proposition}[Conflict-free Set Equivalence]\label{prop:conflict-free-set-equivalence}
  Let forest $F$ be a forest and let $X \subseteq V \times V$ be a
  conflict-free set in $F$ where $|X| = n$. Then defining the following forests:
  \begin{align*}
    F_0 &:= F \\
    F_{i} &:= (V, E_{i - 1} \cup \{(v_i, u_i)\}) \text{ for } (v_i, u_i) \in X \text{ and } 1 \leq i \leq n \\
    G_0 &:= F \\
    G_{j} &:= (V, E_{i - 1} \cup \{(\rho_{G_{j - 1}}(v_j), \rho_{G_{j - 1}}(u_j))\}) \text{ for } (v_j, u_j) \in X \text{ and } 1 \leq j \leq n
  \end{align*}
  Then $F_{n} \cong G_{n}$.
\end{proposition}
\begin{proof}
  Let forest $F$ be a forest, $X \subseteq V \times V$ be a conflict-free set
  in $F$. We will show that $F_n \cong G_n$. We know that for some $(v_i, u_i)
  \in X$ then $v_i \neq y$ for all  $(y, w) \in X \backslash \{(v_i, u_i)\}$
  since otherwise $(V, X)$ would not be a forest and $X$ would not be a
  conflict-free set in $F$. So all edge set unions will only give a root $v_i$
  a new parent $u_i$ once. So $\rho_{F_n}(v_i) = \rho_{F_n}(u_i)$ and
  $\rho_{G_n}(u_i) = \rho_{G_n}(v_i)$ hence $v_i$ remains in the same tree in
  both $F_n$ and $G_n$. Since this holds for all $(v_i, u_i) \in X$ it follows
  that all elements in $V$ remains in the same tree in both $F_n$ and $G_n$.
  Hence $F_n \cong G_n$.
\end{proof}

\begin{proposition}[Ordered Edges Implies Acyclicity]\label{prop:ordered-edges-implies-acyclicity}
  Let $G = (V, E)$ be a directed graph where for all $(v, u) \in E$ it holds
  that $v < u$ for some strict total order $(V, <)$. Then $G$ has no cycles.
\end{proposition}

\begin{proof}
  Let $G = (V, E)$ be a directed graph where for all $(u, v) \in E$ it holds
  that $u < v$ for some total order $(V, <)$. Let edges $e_1, e_2, \ldots, e_m
  \in E$ where $m \geq 1$ and $e_i = (v_{i-1}, v_i)$ for $1 \leq i \leq m$ be
  some path in $G$. Since the edges are ordered it follows that:
  \begin{align*}
    v_0 < v_1 < v_2 < \cdots < v_{m - 1} < v_m
  \end{align*}
  Hence by transitivity of the total order it follows that $v_0 < v_m$. So
  $v_0 \neq v_m$ hence there are no cycles in $G$.
\end{proof}

\begin{proposition}[Inverted Acyclic Graph is Acyclic]\label{prop:inverted-acyclic-graph}
  Let $G = (V, E)$ be a directed acyclic graph. Then the inverted graph $G' =
  (V, E')$ where $E' = \{(u, v) : (v, u) \in E\}$ is also acyclic.
\end{proposition}
\begin{proof}
  Let $G = (V, E)$ be a directed acyclic graph and $G' = (V, E')$ where $E' =
  \{(u, v) : (v, u) \in E\}$ is the inverted graph. Let edges $e_1, e_2,
  \ldots, e_m \in E'$ where $m \geq 1$ and $e_i = (v_{i-1}, v_i)$ for $1 \leq
  i \leq m$ be some path in $G'$. By definition of $E'$ it follows that there
  exists edges $e'_1, e'_2, \ldots, e'_m \in E$ where $e'_i = (v_i, v_{i-1})$
  for $1 \leq i \leq m$. If there was a cycle in $G'$ then it would hold that
  $v_0 = v_m$. But since $G$ is acyclic it follows that $v_0 \neq v_m$. Hence
  there are no cycles in $G'$.  
\end{proof}

\begin{algorithm}[Left Maximal Union]\label{alg:left-maximal-union}
  Let forest $F = (V, E)$ be a forest and let $Z \subseteq \{(\rho_F(v),
  \rho_F(u)) : (v, u) \in V \times V\}$ be a set of root pairs $F$ and $(V,
  Z)$ is an acyclic directed graph. The left maximal conflict-free set
  algorithm is defined as:
  \begin{align*}
    & \id{LeftMaximalUnion}(F, Z) \\ 
    1. & \qquad (V, E) \leftarrow F \\
    2. & \qquad \text{Let } X \subseteq Z \text{ where } \{v : (v, u) \in X\} = \{v : (v, u) \in Z\} \\
    & \qquad \qquad \qquad \quad \: \: \: 
    \: \text{ and } |X| = |\{v : (v, u) \in Z\}| \\
    3. & \qquad E \leftarrow E \cup X \\
    4. & \qquad \kw{return} \: ((V, E), Z \backslash X)
  \end{align*}
\end{algorithm}
\begin{proposition}[Left Maximal Union Correctness]\label{prop:left-maximal-union-correctness}
  Let forest $F = (V, E)$ be a forest and let $Z \subseteq \{(\rho_F(v),
  \rho_F(u)) : (v, u) \in V \times V\}$ be a set of root pairs $F$ and $(V,
  Z)$ is an acyclic directed graph. Then the left maximal conflict-free set
  algorithm returns a forest $F' = (V, E')$ and a conflict-free set $X
  \subseteq Z$ in $F$.
\end{proposition}
\begin{proof}
  Let forest $F = (V, E)$ be a forest and let $Z \subseteq \{(\rho_F(v),
  \rho_F(u)) : (v, u) \in V \times V\}$ be a set of root pairs $F$ and $(V,
  Z)$ is an acyclic directed graph. Since $X$ is defined such that $\{v : (v,
  u) \in X\} = \{v : (v, u) \in Z\}$ and $|X| = |\{v : (v, u) \in Z\}|$ it
  follows that $X$ is a conflict-free set in $F$ since no vertex $v$ appears
  more than once as a child in $X$ i.e. $(V, X)$ is a forest. By adding the
  edges in $X$ to $E$ it follows by proposition
  \ref{prop:conflict-free-forest-union} that $F' = (V, E')$ is a forest where
  $E' = E \cup X$.
\end{proof}

\begin{proposition}[Left Maximal Union Time Complexity]\label{prop:left-maximal-union-time-complexity}
  Let forest $F = (V, E)$ be a forest and let $Z \subseteq \{(\rho_F(v),
  \rho_F(u)) : (v, u) \in V \times V\}$ be a set of root pairs $F$ and $(V,
  Z)$ is an acyclic directed graph. Then the left maximal conflict-free set
  algorithm runs in $O(|Z|)$ work and $O(\log |Z|)$ depth.
\end{proposition}

\begin{proof}
  For step 1. it takes $O(1)$ work and $O(1)$ if we assume that $E$ is only
  used once in this function. Step 2. can be implemented by a parallel sort on
  the first element of each pair in $Z$ followed by a parallel filter that
  selects the first occurrence of each unique first element. This takes
  $O(|Z|)$ work using radix sort with a fixed key length and $O(\log |Z|)$
  depth. Step 3. takes $O(|X|)$ work and $O(1)$ depth to add the edges in $X$
  to $E$. Step 4. takes $O(|Z|)$ work and $O(\log |Z|)$ depth to compute the
  set difference $Z \backslash X$ by a filter. Hence the total work is
  $O(|Z|)$ and the total depth is $O(\log |Z|)$. Hence the left maximal
  conflict-free set algorithm runs in $O(|Z|)$ work and $O(\log |Z|)$ depth.
\end{proof}


\begin{proposition}[Acyclic Directed Graph Presevation]\label{prop:acyclic-directed-graph-preservation}
  Let $G = (V, E)$ be a directed acyclic graph and let $F = (V, X)$ be a
  forest where $X \subseteq E$. Then the directed graph $G' = (V, E')$ where
  $E' = \{(\rho_F(v), \rho_F(u)) : (v, u) \in E \backslash X \land \rho_F(v)
  \neq \rho_F(u)\}$ is also acyclic.
\end{proposition}
\begin{proof}
  Let $G = (V, E)$ be a directed acyclic graph and let $F = (V, X)$ be a
  forest where $X \subseteq E$. Let $q$ be a path $e_1, e_2, \ldots, e_m \in
  E$ where $m \geq 1$ and $e_i = (v_{i-1}, v_i)$ for $1 \leq i \leq m$ be some
  path in $G$.
  \begin{itemize}
    \item If all edges $e_i \notin X$ then the path $q$ exists in $G'$ and
    does not form a cycle since $G$ is acyclic.
    \item If $q$ has some subpath $e_j, e_{j+1}, \ldots, e_k \in X$ for $1
    \leq j < k \leq m$ where $(v_{j - 1}, v_j) \in X$ then $\rho_F(v_{j-1})
    = \rho_F(v_{j})$ so it will not be in $E \backslash X$. Let $(v, u) \in
    E$ where $u  = v_{j - 1}$ or $u = v_j$ then $\rho_F(u) = v_k$ so the
    edge in $G'$ will be $(\rho_F(v), v_k)$.
    \begin{itemize}
      \item If $v \in \{w : (w, u) \in X\}$ then $\rho_F(v) = v_k$ so the
      edge is $(v_k, v_k)$ which is a trivial cycle and since $\rho_F(v)
      \neq \rho_F(u)$ it will not be in $E'$.
      \item If $v \notin \{w : (w, u) \in X\}$ then $\rho_F(v) \neq v_k$
      and $(\rho_F(v), v_k)$ will be an edge in $G'$. And since the path
      $v \leadsto v_k$ in $G$ does not form a cycle it follows that single
      edge from $(\rho_F(v), v_k) \in E'$ does not form a cycle either.
    \end{itemize}
  \end{itemize}
\end{proof}

\begin{algorithm}[Parallel Tree Union]\label{alg:parallel-tree-union}
  Let forest $F = (V, E)$ be a tree and let $A \subseteq V \times V$ be a set of pairs
  of elements in $V$ that will be unioned in parallel. The parallel tree union
  algorithm is defined as:
  \begin{align*}
    & \id{ParallelTreeUnion}(F, A) \\
    1. & \qquad Z_p \leftarrow \{(\rho_F(v), \rho_F(u)) : (v, u) \in A \land \rho_F(v) \neq \rho_F(u)\} \\
    2. & \qquad Z \leftarrow \{(\min \{v, u\}, \max \{v, u\}) : (v, u) \in Z_p\} \\
    3. & \qquad \kw{while }~|Z| > 0~\kw{do} \\
    4. & \quad \qquad (F, Z_q) \leftarrow \id{LeftMaximalUnion}(F, Z) \\
    5. & \qquad \quad Z \leftarrow \{(\rho_{F}(u), \rho_{F}(v)) : (v, u) \in Z_q \land \rho_{F}(v) \neq \rho_{F}(u)\} \\
    6. & \qquad \kw{return} \: F
  \end{align*}
\end{algorithm}

\begin{proposition}[Parallel Tree Union Correctness]
  Let forest $F = (V, E)$ be a tree and let $A \subseteq V \times V$ be a set of pairs
  of elements in $V$ that will be unioned in parallel. Then the parallel tree union
  algorithm returns a forest $F' = (V, E')$ where for all $(v, u) \in A$ it holds that
  $v \sim_{F'} u$.
\end{proposition}

\begin{proposition}[Parallel Tree Union Time Complexity]
  Let forest $F = (V, E)$ be a tree and let $A \subseteq V \times V$ be a set
  of pairs of elements in $V$ that will be unioned in parallel. Then the
  parallel tree union algorithm runs in $O(|A|^2)$ work and $O(|V|)$ span.
\end{proposition}

\subsection{Union by Size and Rank}

\subsection{Parallel Union-Find Imrovements}

\section{Implementation}

\subsection{Interface}
The interface of the union-find structure consists of a data-type which is the
union-find structure itself. The elements in the union-find structure are
represented as integers. These integers are called \textit{handles} and are used
to refer to the elements in the union-find structure. The union-find structure
is initialized with a fixed number of elements $n$ where the handles are in the
range $[0, n - 1]$ so they can be used as indices in an array of size $n$. When
exposing these elements to a user then they are abstract datatypes such that the
the user cannot do uninteneded operations on the handles or give invalid handles
to the union-find structures operations.

The operations supported are \id{find} and \id{union}. The find operation takes
a handle and returns the representative which is also a handle. This can be used
to check if two elements are in the same set or is ``equivalent'' by checking if
their representatives are the same. The union operation takes two handles such
that they have the same representative and are therefore in the same set or to
be considered ``equivalent''. These operations are done in bulk meaning that the
find operation takes an array of handles and union can union multiple pairs of
handles in parallel.

\subsection{Union-find}
The first and simplest implementation of the union-find structure is based on
the basic parallel tree union algorithm \ref{alg:parallel-tree-union}. It will
be extremely inefficient if we do not apply normalization of a left maximal
union since you may produce long chains of elements pointing to each other which
will make the find operation very expensive. This can be solves by compressing
the paths during the find operation such that all elements point directly to
their representative after a left maximal union. This will not optimize a
sequence of union or find operations but assuming you only have to do one
singular bulk union followed by multiple bulk find operations it will be
efficient.

\subsubsection{Data type}
A simple union-find structure can be implemented using an array indices which
where the index represents the element/handle and the value at that index is
the parent of that element. If the value at that index is a special value which
is the highest possible integer value then that element is a root and therefore
its own representative. In pseudo code we denote this as an array of integers:
\begin{flalign*}
  & \id{parents} : [n]\Int &
\end{flalign*}
Initially all of these values are set to \id{none} which indicates that all
elements are their own representative. Here \id{none} is defined as an integer
$n \geq \id{none}$.

\subsubsection{Find}
To implement the find operation we can simple do a parallel map over all
elements to find their representative by a simple loop that follows the
parent pointers until a root is found. Since this operation does not modify the
structure we can simplify implement it as so:
\begin{flalign*}
  & \kw{def}~\id{find\_one}~(\id{parents} : [n]\Int)~(\id{handle} : \Int) = & \\
  & \qquad \If~\id{parents}[\id{handle}] = \id{none} & \\
  & \qquad \kw{then}~\id{handle} & \\
  & \qquad \Else~\id{find}~\id{parents}~(\id{parents}[\id{handle}]) &
\end{flalign*}
Then the bulk find operation can be implemented as:
\begin{flalign*}
  & \kw{def}~\id{find}~(\id{parents} : [n]\Int)~(\id{handles} : [m]\Int) = & \\
  & \qquad \kw{map}~(\id{find\_one}~\id{parents})~\id{handles} &
\end{flalign*}

\subsubsection{Union}
The union operation can be implemented using the parallel tree union algorithm
\ref{alg:parallel-tree-union} but due to its abstract nature one must figure out
how to make it work in the concrete implementation.

The initial step is to find the representatives of all handle pairs that will
be unioned. This can be done by a map followed by a filter to remove pairs
where both elements already have the same representative:
\begin{flalign*}
& \kw{def}~\id{find\_pairs}~(\id{parents} : [n]\Int)~(\id{pairs}: [m](\Int, \Int)) = & \\
& \qquad \Let~\id{find\_one\_pair}~(v, u) = & \\
& \qquad \quad (\id{find\_one}~parents~v,~\id{find\_one}~parents~u) & \\
& \qquad \In ~(\kw{filter}~(\lambda (v, u) \to v \neq u) \circ \kw{map}~\id{find\_one\_pair})~pairs &
\end{flalign*}
The next step is we want to order all pairs such that it forms an acyclic directed graph. This can be done by simply ordering each pair such that the
first element is always less than the second element:
\begin{flalign*}
& \kw{def}~\id{order}~(\id{pairs} : [m](\Int, \Int)) = & \\
& \qquad \kw{map}~(\lambda (v, u) \to \If~v < u~\kw{then}~(v, u)~\Else~(u, v))~\id{pairs} &
\end{flalign*}
Now left maximal union can be performed on the ordered pairs, we do this simply
by selecting one parent for each unique first element in the pairs. This can be
done by a reduce by index operation using \id{min} as the reduction operator.
Now we just have to partition the pairs into those that were successfully
unioned and those that were not. The ones that were not unioned are those where
the parent did not change.

There is just one problem with this approach and it is that this may construct
one long chain of elements pointing to each other which will make future find
operations expensive. This can be solved by normalizing the structure after the
left maximal union such that all elements that were given a new parent now point
directly to their representative. This results in the following left maximal
union implementation:
\begin{flalign*}
& \kw{def}~\id{left\_maximal\_union}~(\id{parents} : [n]\Int)~(\id{pairs} : [m](\Int, \Int)) = & \\
& \qquad \Let~(l, r) = \id{unzip}~\id{pairs} & \\
& \qquad \Let~\id{parents'} = \id{reduce\_by\_index}~\id{parents}~\id{min}~\id{none}~l~r & \\
& \qquad \Let~(\id{remaining}, \id{done}) = \id{partition}~(\lambda (i, p) \to \id{parents'}[i] \neq p)~\id{pairs} & \\
& \qquad \Let~\id{parents''} = \id{normalize}~\id{parents'}~(\kw{map}~(\lambda (x, y) \to x)~\id{done}) & \\
& \qquad \In ~(\id{parents''}, \id{remaining}) &
\end{flalign*}
The normalization step can be implemented by using the wyllie list ranking
algorithm \cite[59]{wyllie1979complexity} to compress the paths in the
union-find structure. The modification is instead of checking if the parent does
not exists we have to check if it is a root or the grandparent is a root then we
are done.
\begin{flalign*}
& \kw{def}~\id{normalize\_step}~(\id{is} : [m]\Int)~(\id{parents} : [n]\Int) = & \\
& \qquad \Let~\id{next}~(\id{handle} : \Int) = & \\
& \qquad \quad \If~\id{parents}[\id{handle}] = \id{none} & \\
& \qquad \quad \kw{then}~\id{handle} & \\
& \qquad \quad \Else~\If~\id{parents}[\id{parents}[\id{handle}]] = \id{none} & \\
& \qquad \quad \kw{then}~\id{parents}[\id{handle}] & \\
& \qquad \quad \Else~\id{parents}[\id{parents}[\id{handle}]] & \\
& \qquad \In~\id{scatter}~\id{parents}~\id{is}~(\kw{map}~\id{next}~\id{is}) &
\end{flalign*}
Then we just have to repeat this process $\lceil \log_2 m \rceil$ times to
ensure that all paths are compressed:
\begin{flalign*}
& \kw{def}~\id{normalize}~(\id{parents} : [n]\Int)~(\id{is} : [m]\Int) = & \\
& \qquad \Let~\id{loop}~(\id{parents'} : [n]\Int)~(\id{is'} : [m]\Int)~(\id{count} : \Int) = & \\
& \qquad \quad \If~\id{count} = 0 & \\
& \qquad \quad \kw{then}~\id{parents'} & \\
& \qquad \quad \Else~\id{normalize\_step}~\id{is'}~\id{parents'} & \\
& \qquad \quad \In ~\id{loop}~\id{parents'}~\id{ps'}~(\id{count} - 1) & \\
& \qquad \In ~\id{loop}~\id{parents}~\id{is}~\lceil\log_2 m\rceil &
\end{flalign*}
The last step in the parallel tree union algorithm is to swap the pairs such
that we can perform left maximal union again on the inverted pairs. This takes
the acyclic directed graph formed by the remaining pairs and inverts all edges:
\begin{flalign*}
  & \kw{def}~\id{swap} ~(\id{pairs} : [n](\Int, \Int)) = & \\
  & \qquad \Map ~(\lambda (v, u) \to (u, v))~\id{pairs} &
\end{flalign*} 
Now we have all the functions needed to implement the union operation:
\begin{flalign*}
& \kw{def}~\id{union}~(\id{parents} : [n]\Int)~(\id{pairs} : [m](\Int, \Int)): [n]\Int = & \\
& \qquad \text{let } pairs =
\end{flalign*}


\subsection{Union by Rank}

\subsection{Union by Size}

\end{document}
